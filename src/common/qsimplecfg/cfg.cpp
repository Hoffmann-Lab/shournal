#include <cassert>

#include <QFile>
#include <QFileInfo>
#include <QTextStream>
#include <QDir>
#include <QDebug>
#include <QLockFile>

#include "cfg.h"
#include "exccfg.h"
#include "util.h"
#include "qformattedstream.h"
#include "cflock.h"
#include "excos.h"
#include "os.h"
#include "interrupt_handler.h"


namespace  {


void setStreamCommentMode(QFormattedStream& s){
    s.setMaxLineWidth(80);
    s.setLineStart("# ");
}

void unsetStreamCommentMode(QFormattedStream& s){
    s.setMaxLineWidth(std::numeric_limits<int>::max());
    s.setLineStart("");
}

void writeMultiLineKey(QFormattedStream& stream, const QString& keyname,
                       const QString& value){
    assert(stream.streamChunkSep() == '\n');

    auto oldMaxLineWidth = stream.maxLineWidth();
    stream.setMaxLineWidth(std::numeric_limits<int>::max());
    const QString TRIPLE_QUOTE = "'''";
    stream << keyname + " = " + TRIPLE_QUOTE;
    auto oldLineStart = stream.lineStart();
    // repsecting oldLineStart makes this function compatible
    // with comment and normal mode.
    stream.setLineStart(oldLineStart + "   ");
    stream << value;
    stream.setLineStart(oldLineStart);
    stream << TRIPLE_QUOTE;
    stream.setMaxLineWidth(oldMaxLineWidth);
}
} // namespace


/// Parse the config file at filepath. Create it, if necessary.
/// Note that the content of multi-line strings between triple quotes
/// is parsed "as is", except for an optional final \n, if the closing triple
/// quotes are in the next line. Example:
/// '''
/// text
/// '''
/// -> no \n after <text> (but before it there is one).
/// So it does not matter, whether the closing triple quotes are in the same
/// or the next line.
/// @throws ExcCfg
qsimplecfg::Cfg::Cfg() :
    m_allowEraseSections(true)
{}

void qsimplecfg::Cfg::parse(const QString &filepath)
{
    createDirsToFilename(filepath);
    QFile file(filepath);

    if(! file.open(QIODevice::OpenModeFlag::ReadOnly | QIODevice::OpenModeFlag::Text)){
        throw ExcCfg(qtr("Failed to open %1 - %2").
                     arg(filepath, file.errorString()));
    }
    parse(file);
}

/// @overload
/// @param file: parse the already for reading opened file (whose offset should typically be zero).
void qsimplecfg::Cfg::parse(QFile &file)
{
    QTextStream in(&file);
    try{
        parse(&in);
    } catch(ExcCfg & ex){
        ex.setDescrip(ex.descrip() +
                       qtr(". Please correct the file at %1").arg(QFileInfo(file).absoluteFilePath()));
        throw;
    }
}

void qsimplecfg::Cfg::store(const QString &filepath)
{
    createDirsToFilename(filepath);
    QFile file(filepath);
    if(! file.open(QIODevice::OpenModeFlag::WriteOnly | QIODevice::OpenModeFlag::Text)){
        throw ExcCfg(qtr("Failed to open %1 - %2").
                     arg(filepath, file.errorString()));
    }
    store(file);
}

/// Save config at given filepath. **Not** safe against races.
/// @throws ExcCfg
void qsimplecfg::Cfg::store(QFile &file)
{
    QFormattedStream stream(&file);
    stream.setStreamChunkSep('\n');
    unsetStreamCommentMode(stream);

    if(! m_initialComments.isEmpty()){
        setStreamCommentMode(stream);
        stream << m_initialComments;
        unsetStreamCommentMode(stream);
    }
    stream << "\n\n";

    for(const auto& nameSect : m_nameSectionHash){
        stream << '[' + nameSect.second.sect->sectionName() + "]";
        writeSectionCommentsToStream(nameSect.second.sect, stream);
        writeSectionToStream(nameSect.second.sect, stream);
        stream << "\n\n";
    }
}


/// Get a parsed section or create a new one with given name.
/// The order in which operator[] is called,
/// determines the order in which it will be stored to disk on Cfg::store().
/// Parsed sections ( see parse() ) which were not requested via this function,
/// will *not* be store()'ed. The idea is that the config scheme is autogenerated
/// by requesting the sections and keys.
/// Note that calling this function a second time with the same section name,
/// after another section was created, does *not* change the order.
/// @return the Section_Ptr is never null.
qsimplecfg::Cfg::Section_Ptr qsimplecfg::Cfg::operator[](const QString &sectName)
{
    auto parsedIt = m_parsedNameSectionHash.find(sectName);
    if(parsedIt != m_parsedNameSectionHash.end()){
        SectWithMeta sectMeta;
        sectMeta.sect = parsedIt->second;
        m_nameSectionHash.insert({sectName, sectMeta});
        m_parsedNameSectionHash.erase(parsedIt);
        return sectMeta.sect;
    }

    // section was not parsed or requested a second time: get or create:
    auto & sectMeta = m_nameSectionHash[sectName];
    if(sectMeta.sect == nullptr){
        sectMeta.sect = make_shared_section(sectName);
    }
    return sectMeta.sect;
}


void qsimplecfg::Cfg::handleParseKeyValue(QStringRef &line, size_t *pLineNumber,
                                     QTextStream *stream,const Section_Ptr& section)
{
    int equalIdx = line.indexOf('=');
    if(equalIdx == -1){
        throw ExcCfg(qtr("Line %1 - %2: Unexpected content (missing =)").
                     arg(*pLineNumber).arg(line.toString()));
    }

    QStringRef key = line.left(equalIdx).trimmed();
    QStringRef value = line.mid(equalIdx + 1).trimmed();
    if(! value.startsWith("'''")){
        // simple case: not a multi-line string
        section->insert(key.toString(), value.toString());
        return;
    }

    // ignore leading '''
    value = value.mid(3);
    // still possible that string ends in same line:
    int tripleIdx = value.indexOf("'''");
    if(tripleIdx != -1){
        if(tripleIdx != value.length()-3){
            throw ExcCfg(qtr("Line %1 - %2: content after closing triple quotes '''").
                         arg(*pLineNumber).arg(line.toString()));
        }
        section->insert(key.toString(), value.left(value.size() - 3).toString());
        return;
    }

    m_keyValBuf = value.toString();

    // mutli line string: keep going through file until the
    // next '''
    size_t startingLine = *pLineNumber;
    while (true) {
        if(! readLineInto(*stream, &m_keyValReadBuf)){
            break;
        }
        (*pLineNumber)++;
        QStringRef currentLine(&m_keyValReadBuf);
        currentLine = currentLine.trimmed();

        tripleIdx = currentLine.indexOf("'''");
        if(tripleIdx == -1){
            // keep \n's for later split
            m_keyValBuf += '\n' + currentLine.toString() ;
            continue;
        }
        if(tripleIdx != currentLine.length()-3){
            throw ExcCfg(qtr("Line %1 - %2: content after closing triple quotes '''").
                         arg(*pLineNumber).arg(currentLine.toString()));
        }
        if(tripleIdx != 0){            
            m_keyValBuf += '\n' + currentLine.left(currentLine.size() - 3).toString();
        }
        section->insert(key.toString(), m_keyValBuf);
        return;
    }
    throw ExcCfg(qtr("Line %1 - %2: missing closing triple quotes '''").
                 arg(startingLine).arg(line.toString()));


}

void
qsimplecfg::Cfg::writeKeyValue(const QString &key,
                               const QString &val,
                               const QString &sep,
                               QFormattedStream &stream)
{
    if(sep.contains('\n') ||
            val.contains('\n')){
        writeMultiLineKey(stream, key, val);
    } else {
        stream << key + " = " + val;
    }
}

void
qsimplecfg::Cfg::writeSectionToStream(const qsimplecfg::Cfg::Section_Ptr &sect,
                                      QFormattedStream &stream)
{
    for(const auto & keyValMeta : sect->keyValHash()){
        QString valStr;
        if(keyValMeta.second.insertDefault){
            valStr =   QVariantListToString(
                        keyValMeta.second.defaultValues,
                        keyValMeta.second.separator);
        } else {
            if(keyValMeta.second.rawStr.isNull()){
                // No value was parsed and default shall
                // not be inserted -> do not write this
                // key to file.
                continue;
            }
            valStr = keyValMeta.second.rawStr.trimmed();
        }
        writeKeyValue(keyValMeta.first, valStr, keyValMeta.second.separator, stream);
    }
}

void
qsimplecfg::Cfg::writeSectionCommentsToStream(const qsimplecfg::Cfg::Section_Ptr &sect,
                                                   QFormattedStream &stream)
{
    setStreamCommentMode(stream);
    if(! sect->comments().isEmpty()){
        stream << sect->comments() + '\n';
    }
    for(const auto& keyValMeta : sect->keyValHash()){
        const auto & key = keyValMeta.first;
        const auto & valMeta = keyValMeta.second;
        if(! valMeta.insertDefaultToComments){
            continue;
        }
        const QString defaultValStr =  QVariantListToString(valMeta.defaultValues, valMeta.separator);
        writeKeyValue(key, defaultValStr, valMeta.separator, stream);
    }
    unsetStreamCommentMode(stream);
}


/// @throws ExcCfg
void
qsimplecfg::Cfg::createDirsToFilename(const QString &filename)
{
    assert(! filename.isEmpty());
    QFileInfo fileInfo(filename);
    if(! QDir().mkpath(fileInfo.absolutePath())){
        throw ExcCfg(qtr("Failed to create directories for path %1")
                                 .arg(fileInfo.absolutePath()) );
    }
}


QString
qsimplecfg::Cfg::QVariantListToString(const QVariantList &l, const QString &sep)
{
    QString str;
    for(const auto& v : l){
        str += qVariantTo_throw<QString>(v) + sep;
    }
    return str;
}



void qsimplecfg::Cfg::setInitialComments(const QString &comments)
{
    m_initialComments = comments;
}



/// Return all sections and their keys which were not read after having been
/// inserted.
qsimplecfg::NotReadSectionKeys
qsimplecfg::Cfg::generateNonReadSectionKeyPairs()
{
    NotReadSectionKeys allNotRead;
    for(auto it = m_nameSectionHash.begin(); it != m_nameSectionHash.end(); ++it){
       auto notReadKeys = it.value().sect->notReadKeys();
       if(! notReadKeys.empty()){
           allNotRead.push_back({it.key(), notReadKeys});
       }
    }
    return allNotRead;
}

/// Rename a parsed section. Warning: it is *not* allowed, to call this function
/// after having accessed a section via operator[], because that would destroy
/// the order of the sections.
/// @return true, if the old section existed.
bool qsimplecfg::Cfg::renameParsedSection(const QString &oldName, const QString &newName)
{
    assert(m_nameSectionHash.empty());
    auto oldIt = m_parsedNameSectionHash.find(oldName);
    if(oldIt == m_parsedNameSectionHash.end()){
        return false;
    }
    Section_Ptr sect = oldIt->second;
    sect->setSectionName(newName);
    m_parsedNameSectionHash.erase(oldIt);

    m_parsedNameSectionHash[newName] = sect;
    return true;
}

/// @return those sections which were parsed but not accessed via operator[]
const qsimplecfg::Cfg::ParsedNameSectionHash&
qsimplecfg::Cfg::getParsedButNotReadNameSectionHash() const
{
    return m_parsedNameSectionHash;
}


/// Get a parsed section. Warning: it is *not* allowed, to call this function
/// after having accessed a section via operator[], because that would destroy
/// the order of the sections. So call this function after Cfg::parse but before
/// accessing any section via operator[].
/// @return the parsed section or null
qsimplecfg::Cfg::Section_Ptr qsimplecfg::Cfg::getParsedSectionIfExist(const QString &sectName)
{
    assert(m_nameSectionHash.empty());
    auto it = m_parsedNameSectionHash.find(sectName);
    if(it == m_parsedNameSectionHash.end()){
        return nullptr;
    }
    return it->second;
}

/// @overload
void qsimplecfg::Cfg::parse(QTextStream *in)
{
    m_parsedNameSectionHash.clear();
    m_nameSectionHash.clear();
    m_initialComments.clear();

    bool withinSection=false;
    Section_Ptr currentSect;
    QString currentSectName;
    size_t currentLine = 0;

    QString lineBuf;
    lineBuf.reserve(8192);
    while (true) {
        if(! readLineInto(*in, &lineBuf)){
            break;
        }

        QStringRef line(&lineBuf);
        line = line.trimmed();
        currentLine++;

        if(line.startsWith('#')){
            // No point in reading comments.
        } else if(line.isEmpty()){

        } else if(line.startsWith('[')){
            if(! line.endsWith(']')){
                throw ExcCfg(qtr("Line %1 - %2: section start [ without closing end ] detected").
                             arg(currentLine).arg(line.toString()));
            }
            withinSection = true;
            currentSectName = line.mid(1, line.size() - 2).toString();
            if(currentSectName.isEmpty()){
                throw ExcCfg(qtr("Line %1 - %2: empty section detected").
                             arg(currentLine).arg(line.toString()));
            }
            auto currentSectIt = m_parsedNameSectionHash.find(currentSectName);
            if(currentSectIt != m_parsedNameSectionHash.end()){
                throw ExcCfg(qtr("Line %1 - %2: section name already defined (in upper line)").
                             arg(currentLine).arg(line.toString()));
            }
            currentSect = make_shared_section(currentSectName);
            m_parsedNameSectionHash.insert({currentSectName, currentSect});
        } else {
            if(! withinSection){
                throw ExcCfg(qtr("Line %1 - %2: Content before first section").
                             arg(currentLine).arg(line.toString()));
            }
            handleParseKeyValue(line, &currentLine, in, currentSect );
        }
    }
}
