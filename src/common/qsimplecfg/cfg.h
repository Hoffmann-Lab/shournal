
#pragma once

#include <memory>
#include <unordered_map>
#include <QString>
#include <QHash>
#include <QStringList>

#include "section.h"

class QTextStream;
class CfgTest; // unit test
class QFormattedStream;

namespace qsimplecfg {

/// First Element of each pair is section-name, second a set of not read keys
typedef QVector<QPair<QString, std::unordered_set<QString> > > NotReadSectionKeys ;


/// A simple parser for ini-like config files.
/// The scheme of the config file, that is: the order of sections
/// and keys and their default values is autogenerated by subsequent
/// calls to Cfg::operator[] and Section::getValue. *Only* those sections
/// and keys are written (back) to the config-file, which were accessed
/// by these methods. The order written to file is exactly the access order.
/// Scheme updates work by renaming sections (Cfg::renameParsedSection) and
/// keys (Section::renameParsedKey) after Cfg::parse but before accessing
/// a value via the above described methods. To rename a key, obtain
/// the section via Cfg::getParsedSectionIfExist and *not* Cfg::operator[].
///
/// No subsections are supported but:
/// - initial file comment
/// - comments after a section header:
///   [sectionname]
///   # comment1
///   # comment2
/// - values over multiple lines with triple quotes ''':
///   key = '''foo1
///         foo2'''
/// - comments are always re-written by the application on store(),
///   but ignored when parsing the file.
class Cfg
{
public:
    typedef std::shared_ptr<Section> Section_Ptr;
    typedef std::unordered_map<QString, Section_Ptr> ParsedNameSectionHash;

    Cfg();

    void parse(const QString& filepath);
    void parse(QFile& file);
    void store(const QString& filepath);

    Section_Ptr operator[](const QString &sectName);

    void setInitialComments(const QString &comments);

    NotReadSectionKeys generateNonReadSectionKeyPairs();

    bool renameParsedSection(const QString& oldName, const QString& newName);

    const ParsedNameSectionHash& getParsedButNotReadNameSectionHash() const;

    Section_Ptr getParsedSectionIfExist(const QString& sectName);

private:
    // maybe_todo: store plain section instead, if sure, that no metadata
    // about it needs to be stored...
    struct SectWithMeta {   
        Section_Ptr sect;
    };

    typedef tsl::ordered_map<QString, SectWithMeta> SectionHash;

    ParsedNameSectionHash m_parsedNameSectionHash; // parsed from file
    SectionHash m_nameSectionHash; // accessed by user via operator[]
    QString m_initialComments;
    QString m_keyValReadBuf;
    QString m_keyValBuf;
    bool m_allowEraseSections;

    void parse(QTextStream *in);
    void handleParseKeyValue(QStringRef &line,
                        size_t* pLineNumber,
                        QTextStream* stream,
                        const Section_Ptr &section);
    void writeKeyValue(const QString& key, const QString& val,
                       const QString& sep, QFormattedStream& stream);
    void writeSectionToStream(const Section_Ptr& sect, QFormattedStream& stream);
    void writeSectionCommentsToStream(const Section_Ptr& sect, QFormattedStream& stream);


    static void createDirsToFilename(const QString& filename);

    static std::shared_ptr<Section> make_shared_section(const QString& sectName)  {
        // since section is private, but make_shared requires it to be public, the dummy inheritance is
        // one soultion
        struct allow_mk_shared : public Section {
            allow_mk_shared(const QString& sectName) : Section(sectName) {}
        };
        return std::make_shared<allow_mk_shared>(sectName);
    }
    static QString QVariantListToString(const QVariantList& l, const QString& sep);


    // unit test:
    friend class ::CfgTest;
};

} // namespace qsimplecfg
